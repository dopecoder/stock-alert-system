// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package data_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LTPServiceClient is the client API for LTPService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LTPServiceClient interface {
	WatchLTPforInstruments(ctx context.Context, in *Instruments, opts ...grpc.CallOption) (LTPService_WatchLTPforInstrumentsClient, error)
}

type lTPServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLTPServiceClient(cc grpc.ClientConnInterface) LTPServiceClient {
	return &lTPServiceClient{cc}
}

func (c *lTPServiceClient) WatchLTPforInstruments(ctx context.Context, in *Instruments, opts ...grpc.CallOption) (LTPService_WatchLTPforInstrumentsClient, error) {
	stream, err := c.cc.NewStream(ctx, &LTPService_ServiceDesc.Streams[0], "/data_service.LTPService/WatchLTPforInstruments", opts...)
	if err != nil {
		return nil, err
	}
	x := &lTPServiceWatchLTPforInstrumentsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LTPService_WatchLTPforInstrumentsClient interface {
	Recv() (*LTP, error)
	grpc.ClientStream
}

type lTPServiceWatchLTPforInstrumentsClient struct {
	grpc.ClientStream
}

func (x *lTPServiceWatchLTPforInstrumentsClient) Recv() (*LTP, error) {
	m := new(LTP)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LTPServiceServer is the server API for LTPService service.
// All implementations must embed UnimplementedLTPServiceServer
// for forward compatibility
type LTPServiceServer interface {
	WatchLTPforInstruments(*Instruments, LTPService_WatchLTPforInstrumentsServer) error
	mustEmbedUnimplementedLTPServiceServer()
}

// UnimplementedLTPServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLTPServiceServer struct {
}

func (UnimplementedLTPServiceServer) WatchLTPforInstruments(*Instruments, LTPService_WatchLTPforInstrumentsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchLTPforInstruments not implemented")
}
func (UnimplementedLTPServiceServer) mustEmbedUnimplementedLTPServiceServer() {}

// UnsafeLTPServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LTPServiceServer will
// result in compilation errors.
type UnsafeLTPServiceServer interface {
	mustEmbedUnimplementedLTPServiceServer()
}

func RegisterLTPServiceServer(s grpc.ServiceRegistrar, srv LTPServiceServer) {
	s.RegisterService(&LTPService_ServiceDesc, srv)
}

func _LTPService_WatchLTPforInstruments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Instruments)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LTPServiceServer).WatchLTPforInstruments(m, &lTPServiceWatchLTPforInstrumentsServer{stream})
}

type LTPService_WatchLTPforInstrumentsServer interface {
	Send(*LTP) error
	grpc.ServerStream
}

type lTPServiceWatchLTPforInstrumentsServer struct {
	grpc.ServerStream
}

func (x *lTPServiceWatchLTPforInstrumentsServer) Send(m *LTP) error {
	return x.ServerStream.SendMsg(m)
}

// LTPService_ServiceDesc is the grpc.ServiceDesc for LTPService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LTPService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "data_service.LTPService",
	HandlerType: (*LTPServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchLTPforInstruments",
			Handler:       _LTPService_WatchLTPforInstruments_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "data_service.proto",
}

// LTPServiceManagerClient is the client API for LTPServiceManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LTPServiceManagerClient interface {
	WatchLTPforInstruments(ctx context.Context, in *Instruments, opts ...grpc.CallOption) (LTPServiceManager_WatchLTPforInstrumentsClient, error)
}

type lTPServiceManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewLTPServiceManagerClient(cc grpc.ClientConnInterface) LTPServiceManagerClient {
	return &lTPServiceManagerClient{cc}
}

func (c *lTPServiceManagerClient) WatchLTPforInstruments(ctx context.Context, in *Instruments, opts ...grpc.CallOption) (LTPServiceManager_WatchLTPforInstrumentsClient, error) {
	stream, err := c.cc.NewStream(ctx, &LTPServiceManager_ServiceDesc.Streams[0], "/data_service.LTPServiceManager/WatchLTPforInstruments", opts...)
	if err != nil {
		return nil, err
	}
	x := &lTPServiceManagerWatchLTPforInstrumentsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LTPServiceManager_WatchLTPforInstrumentsClient interface {
	Recv() (*LTP, error)
	grpc.ClientStream
}

type lTPServiceManagerWatchLTPforInstrumentsClient struct {
	grpc.ClientStream
}

func (x *lTPServiceManagerWatchLTPforInstrumentsClient) Recv() (*LTP, error) {
	m := new(LTP)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LTPServiceManagerServer is the server API for LTPServiceManager service.
// All implementations must embed UnimplementedLTPServiceManagerServer
// for forward compatibility
type LTPServiceManagerServer interface {
	WatchLTPforInstruments(*Instruments, LTPServiceManager_WatchLTPforInstrumentsServer) error
	mustEmbedUnimplementedLTPServiceManagerServer()
}

// UnimplementedLTPServiceManagerServer must be embedded to have forward compatible implementations.
type UnimplementedLTPServiceManagerServer struct {
}

func (UnimplementedLTPServiceManagerServer) WatchLTPforInstruments(*Instruments, LTPServiceManager_WatchLTPforInstrumentsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchLTPforInstruments not implemented")
}
func (UnimplementedLTPServiceManagerServer) mustEmbedUnimplementedLTPServiceManagerServer() {}

// UnsafeLTPServiceManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LTPServiceManagerServer will
// result in compilation errors.
type UnsafeLTPServiceManagerServer interface {
	mustEmbedUnimplementedLTPServiceManagerServer()
}

func RegisterLTPServiceManagerServer(s grpc.ServiceRegistrar, srv LTPServiceManagerServer) {
	s.RegisterService(&LTPServiceManager_ServiceDesc, srv)
}

func _LTPServiceManager_WatchLTPforInstruments_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Instruments)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LTPServiceManagerServer).WatchLTPforInstruments(m, &lTPServiceManagerWatchLTPforInstrumentsServer{stream})
}

type LTPServiceManager_WatchLTPforInstrumentsServer interface {
	Send(*LTP) error
	grpc.ServerStream
}

type lTPServiceManagerWatchLTPforInstrumentsServer struct {
	grpc.ServerStream
}

func (x *lTPServiceManagerWatchLTPforInstrumentsServer) Send(m *LTP) error {
	return x.ServerStream.SendMsg(m)
}

// LTPServiceManager_ServiceDesc is the grpc.ServiceDesc for LTPServiceManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LTPServiceManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "data_service.LTPServiceManager",
	HandlerType: (*LTPServiceManagerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchLTPforInstruments",
			Handler:       _LTPServiceManager_WatchLTPforInstruments_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "data_service.proto",
}
